---
title: "27ος ΠΔΠ Α' Φάση: Το κυλικείο του σχολείου (xxx) - Λύση"
layout: post
tags: []
comments: true
---

## Brute force λύση

Πρέπει να βρούμε πόσα παιδιά βλέπουν την είσοδο του κυλικείου. Γνωρίζουμε ότι ένα παιδί βλέπει την είσοδο αν και μόνο αν όλα τα παιδιά που στέκονται μπροστά του έχουν ύψος μικρότερο από το δικό του.

Επομένως, μία σκέψη θα ήταν για κάθε παιδί να ελέγχουμε αν είναι ψηλότερο από όλα τα παιδιά που βρίσκονται μπροστά του. Δηλαδή για κάθε παιδί, $$i$$, να διατρέχουμε τον πίνακα $$A$$, στον οποίο έχουμε αποθηκεύσει τα ύψη των παιδιών, από τη θέση $$j = i + 1$$ μέχρι και την $$j = N - 1$$ και να βλέπουμε αν όλα τα $$A[j]$$ είναι μικρότερα από το $$A[i]$$.

Η boolean μεταβλητή $$ok$$ που χρησιμοποιούμε στον κώδικα που φαίνεται παρακάτω αρχικοποιείται σε $$true$$ για κάθε παιδί $$i$$ και γίνεται $$false$$ αν βρεθεί κάποιο $$j > i: A[j] \geq A[i]$$, δηλαδή αν υπάρχει κάποιο παιδί μπροστά από το $$i$$-οστό το οποίο έχει ύψος μεγαλύτερο ή ίσο από το δικό του, εμποδίζοντάς το να δει την είσοδο.

Το πόσα παιδιά βλέπουν το κυλικείο θα το μετράμε με τη βοήθεια της μεταβλητής $$K$$. Η μεταβλητή $$K$$ θα είναι αρχικοποιημένη στο $$0$$ και όποτε συναντάμε ένα παιδί που μπορεί να δει το κυλικείο, δηλαδή η μεταβλητή $$ok$$ παραμένει $$true$$ για αυτό, θα την αυξάνουμε κατά ένα.

Όταν ελέγξουμε όλα τα παιδιά, δηλαδή όλα τα $$i \in \{0, 1, \dots, N - 1\}$$ η μεταβλητή $$K$$ θα αποτελεί τη ζητούμενη απάντηση, οπότε αρκεί να την εκτυπώσουμε.

Η πολυπλοκότητα του αλγορίθμου είναι $$O(N^2)$$ και χρειάζεται $$O(N)$$ μνήμη. Η πολυπλοκότητα αυτή δεν είναι αρκετά καλή και παρόλο που θα επιτρέψει στη λύση μας να πάρει κάποιες μονάδες, δε θα μπορέσει να περάσει όλα τα testcases λόγω υπέρβασης του χρονικού ορίου εκτέλεσης.

{% highlight c++ %}
#include <cstdio>
using namespace std;

const int MAXN = 1e6 + 5;

int A[MAXN];

int main() {
	freopen("xxx.in", "r", stdin);
	freopen("xxx.out", "w", stdout);
	int N;
	scanf("%d", &N);
	for (int i = 0; i < N; i++)
		scanf("%d", &A[i]);
	int K = 0;
	for (int i = 0; i < N; i++) {
		bool ok = true;
		for (int j = i + 1; j < N; j++) {
			if (A[j] >= A[i]) {
				ok = false;
				break;
			}
		}
		if (ok)
			K++;
	}
	printf("%d\n", K);
	return(0);
}
{% endhighlight %}


## Βέλτιση Λύση
Η πολυπλοκότητα της λύσης μας μπορεί να βελτιωθεί σημαντικά αν παρατηρήσουμε ότι ένα παιδί βλέπει την είσοδο του κυλικείου αν και μόνο αν το ψηλότερο από τα παιδιά που βρίσκονται μπροστά του είναι πιο κοντό από αυτό. Ισοδύναμα το $$i$$-οστό παιδί βλέπει την είσοδο αν ισχύει ότι $$A[i] > \max_{i + 1 \leq j \leq N - 1}(A[j])$$. Επίσης πρέπει να παρατηρήσουμε ότι $$\max_{i + 1 \leq j \leq N - 1}(A[j]) = \max(A[i + 1], \max_{i + 2 \leq j \leq N - 1}(A[j]))$$.

Μπορούμε λοιπόν να ορίσουμε μία βοηθητική μεταβλητή $$mx$$ η οποία θα είναι ίση με $$\max_{i + 1 \leq j \leq N - 1}(A[j])$$ όταν ελέγχουμε αν το $$i$$-οστό παιδί βλέπει το κυλικείο, δηλαδή θα ισούται με το ύψος του ψηλότερου παιδιού που βρίσκεται μπροστά του. Σύμφωνα με τη δεύτερη παρατήρηση, βλέπουμε ότι η μεταβλητή $$mx$$ μπορεί να υπολογίζεται σε $$O(1)$$ κάθε φορά, αν διατρέχουμε τον πίνακα από τα δεξιά προς τα αριστερά, μειώνοντας το $$i$$, και σε κάθε βήμα θέτουμε $$mx = \max(A[i + 1], mx)$$. Αυτή η μέθοδος υπολογισμού είναι που οδηγεί στη βελτιστοποίηση της πολυπλοκότητας του αλγορίθμου.

Έχοντας πλέον τη μεταβλητή $$mx$$ να έχει την κατάλληλη τιμή σε κάθε επανάληψη (για κάθε $$i$$), μπορούμε να ελέγχουμε άμεσα αν το $$i$$-οστό παιδί βλέπει την είσοδο, ελέγχοντας αν $$A[i] > mx$$. Σε περίπτωση που ισχύει η ανισότητα αυτή η είσοδος είναι ορατή από το παιδί που εξετάζουμε και πρέπει να αυξήσουμε το $$K$$ κατά $$1$$.

Όταν εξετάσουμε όλα τα παιδιά, η μεταβλητή $$K$$ θα περιέχει την απάντηση, όπως και στην brute force λύση, οπότε αρκεί να την εκτυπώσουμε.

Αφού για κάθε ένα από τα $$N$$ παιδιά κάνουμε τις ενέργειες που περιγράψαμε σε $$O(1)$$, η πολυπλοκότητα του αλγορίθμου είναι $$O(N)$$. Επίσης ο αλγόριθμος χρειάζεται $$O(N)$$ μνήμη.

{% highlight c++ %}
#include <cstdio>
using namespace std;

const int MAXN = 1e6 + 5;

int A[MAXN];

int main() {
	freopen("xxx.in", "r", stdin);
	freopen("xxx.out", "w", stdout);
	int N;
	scanf("%d", &N);
	for (int i = 0; i < N; i++)
		scanf("%d", &A[i]);
	int K = 1, mx = A[N - 1];
	for (int i = N - 2; i >= 0; i--) {
		if (A[i] > mx) {
			K++;
			mx = A[i];
		}
	}
	printf("%d\n", K);
	return(0);
}
{% endhighlight %}
